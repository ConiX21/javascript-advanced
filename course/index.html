<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Javascript advanced</title>
    <script src="/lib/jquery.min.js"></script>
    <link rel="stylesheet" href="/content/impress-demo.css">
    <style>
        p {
            font-size: 0.6em;
            text-align: justify;
            text-justify: inter-word;
            text-indent: 50px;
            padding: 10px;
        }



        div[id^=layer] h1,
        p mark {
            color: #d6c101;
        }

        p mark {
            font-style: italic;
            background-color: transparent;
        }
    </style>
</head>

<body>
    <h1>Course</h1>
    <div id="impress">
        <div id="title" class="step" data-x="0" data-y="0" data-scale="1">
            <span class="try">Nicolas GASQUET</span>
            <h1>Javascript</h1>
        </div>
        <div id="layer1" class="step" data-x="1000" data-y="0" data-scale="1">
            <h1>Object</h1>
            <p>Object literals provide a very convenient notation for creating new object values. An object literal is a pair
                of curly braces surrounding zero or more name/value pairs.
            </p>
            <p>
                A property’s name can be any string, including the empty string. The quotes around a property’s name in an object literal
                are optional if the name would be a legal JavaScript name and not a reserved word.
            </p>
        </div>
        <div id="layer1_1" class="step" data-x="1000" data-y="1000" data-scale="1">
            <h2>Retrieval</h2>
            <p>The || operator can be used to fill in default values.
            </p>
            <p>Attempting to retrieve values from
                <mark>undefined</mark> will throw a TypeError exception. This can be guarded against with the && operator.</p>
        </div>
        <div id="layer1_2" class="step" data-x="1000" data-y="2000" data-scale="1">
            <h2>Update</h2>
            <p>A value in an object can be updated by assignment. If the property name already exists in the object, the property
                value is replaced.
            </p>
        </div>
        <div id="layer1_3" class="step" data-x="1000" data-y="3000" data-scale="1">
            <h2>Reference</h2>
            <p>Objects are passed around by reference. They are never copied.
            </p>
        </div>
        <div id="layer2" class="step" data-x="2000" data-y="0" data-scale="1">
            <h1>Prototype</h1>
            <p>
                Every object is linked to a prototype object from which it can inherit properties. All objects created from object literals
                are linked to Object.prototype, an object that comes standard with JavaScript
            </p>
            <p>
                When you make a new object, you can select the object that should be its prototype. The mechanism that JavaScript provides
                to do this is messy and complex, but it can be significantly simplified. We will add a create method to the
                Object function. The create method creates a new object that uses an old object as its prototype.
            </p>
        </div>
        <div id="layer2_1" class="step" data-x="2000" data-y="1000" data-scale="1">
            <p>
                The prototype link is used only in retrieval. If we try to retrieve a property value from an object, and if the object lacks
                the property name, then JavaScript attempts to retrieve the property value from the prototype object. And
                if that object is lacking the property, then it goes to its prototype, and so on until the process finally
                bottoms out with Object.prototype. If the desired property exists nowhere in the prototype chain, then the
                result is the undefined value. This is called delegation.
            </p>
            <p>
                The prototype relationship is a dynamic relationship. If we add a new property to a prototype, that property will immediately
                be visible in all of the objects that are based on that prototype.
            </p>
        </div>
        <div id="layer2_2" class="step" data-x="2000" data-y="2000" data-scale="1">
            <h1>
                Reflections
            </h1>
            <p>
                It is easy to inspect an object to determine what properties it has by attempting to retrieve the properties and examining
                the values obtained. The typeof operator can be very helpful in determining the type of a property.
            </p>
            <p>
                Some care must be taken because any property on the prototype chain can produce a value.
            </p>
            <p>
                There are two approaches to dealing with these undesired properties. The first is to have your program look for and reject
                function values. Generally, when you are reflecting, you are interested in data, and so you should be aware
                that some values could be functions.
            </p>
            <p>
                The other approach is to use the hasOwnProperty method, which returns true if the object has a particular property. The hasOwnProperty
                method does not look at the prototype chain.
            </p>
        </div>
        <div id="layer2_3" class="step" data-x="2000" data-y="3000" data-scale="1">
            <h1>Enumeration</h1>
            <p>
                The for in statement can loop over all of the property names in an object. The enumeration will include all of the properties—including
                functions and prototype properties that you might not be interested in—so it is necessary to filter out the
                values youdon’t want. The most common filters are the hasOwnProperty method and using typeof to exclude functions.

            </p>
            <p>
                There is no guarantee on the order of the names, so be prepared for the names to appear in any order. If you want to assure
                that the properties appear in a particular order, it is best to avoid the for in statement entirely and instead
                make an array containing the names of the properties in the correct order.
            </p>
        </div>
        <div id="layer2_4" class="step" data-x="2000" data-y="4000" data-scale="1">
            <h1>Delete</h1>
            <p>The delete operator can be used to remove a property from an object. It will remove a property from the object
                if it has one. It will not touch any of the objects in the prototype linkage.
            </p>
            <p>Removing a property from an object may allow a property from the prototype linkage to shine through.</p>
        </div>
        <div id="layer3" class="step" data-x="3000" data-y="0" data-scale="1">
            <h1>Functionnal</h1>
            <p>
                A function encloses a set of statements. Functions are the fundamental modular unit of JavaScript. They are used for code
                reuse, information hiding, and composition. Functions are used to specify the behavior of objects. Generally,
                the craft of programming is the factoring of a set of requirements into a set of functions and data structures.
            </p>
        </div>
        <div id="layer3_1" class="step" data-x="3000" data-y="1000" data-scale="1">
            <h1>Function Objects</h1>
            <p>
                Functions in JavaScript are objects. Objects are collections of name/value pairs having a hidden link to a prototype object.
                Objects produced from object literals are linked to Object.prototype. Function objects are linked to Function.prototype
                (which is itself linked to Object.prototype). Every function is also created with two additional hidden properties:
                the function’s context and the code that implements the function’s behavior.
            </p>
            <p>
                Every function object is also created with a prototype property. Its value is an object with a constructor property whose
                value is the function. This is distinct from the hidden link to Function.prototype
            </p>
            <p>
                Since functions are objects, they can be used like any other value. Functions can be stored in variables, objects, and arrays.
                Functions can be passed as arguments to functions, and functions can be returned from functions. Also, since
                functions are objects, functions can have methods.
            </p>
        </div>
        <div id="layer3_2" class="step" data-x="4000" data-y="1000" data-scale="1">
            <h1>Function Literal</h1>
            <p>
                Function objects are created with function literals
            </p>
        </div>
        <div id="layer3_3" class="step" data-x="5000" data-y="1000" data-scale="1">
            <h1>The Method Invocation Pattern</h1>
            <p>
                When a function is stored as a property of an object, we call it a
                <mark>method</mark>. When a method is invoked, this is bound to that object. If an invocation expression contains
                a refinement (that is, a . dot expression or [subscript] expression), it is invoked as a method.
            </p>
        </div>
        <div id="layer3_4" class="step" data-x="6000" data-y="1000" data-scale="1">
            <h1>The Function Invocation Pattern</h1>
            <p>
                When a function is not the property of an object, then it is invoked as a
                <mark>function</mark>
            </p>
        </div>
        <div id="layer3_5" class="step" data-x="7000" data-y="1000" data-scale="1">
            <h1>The Constructor Invocation Pattern</h1>
            <p>
                JavaScript is a prototypal inheritance language. That means that objects can inherit properties directly from other objects.
                The language is class-free.
            </p>
            <p>
                If a function is invoked with the new prefix, then a new object will be created with a hidden link to the value of the function’s
                prototype member, and this will be bound to that new object.
            </p>
        </div>
        <div id="layer3_6" class="step" data-x="8000" data-y="1000" data-scale="1">
            <h1>Arguments</h1>
            <p>
                A bonus parameter that is available to functions when they are invoked is the arguments array. It gives the function access
                to all of the arguments that were supplied with the invocation, including excess arguments that were not
                assigned to parameters.
            </p>

        </div>
        <div id="layer3_7" class="step" data-x="9000" data-y="1000" data-scale="1">
            <h1>Exception</h1>
            <p>
                JavaScript provides an exception handling mechanism. Exceptions are unusual (but not completely unexpected) mishaps that
                interfere with the normal flow of a program.</p>
            <p>
                The throw statement interrupts execution of the function. It should be given an exception object containing a name property
                that identifies the type of the exception, and a descriptive message property.
            </p>

        </div>
        <div id="layer3_8" class="step" data-x="10000" data-y="1000" data-scale="1">
            <h1>Closure</h1>
            <p>The good news about scope is that inner functions get access to the parameters and variables of the functions
                they are defined within (with the exception of this and arguments).
            </p>
        </div>
        <div id="layer3_9" class="step" data-x="11000" data-y="1000" data-scale="1">
            <h1>Callback</h1>
            <p>Functions can make it easier to deal with discontinuous events. For example, suppose there is a sequence that
                begins with a user interaction, making a request of the server, and finally displaying the server’s response.
            </p>
        </div>
        <div id="layer3_10" class="step" data-x="11000" data-y="1000" data-scale="1">
            <h1>Module</h1>
            <p>We can use functions and closure to make modules. A module is a function or object that presents an interface
                but that hides its state and implementation. By using functions to produce modules, we can almost completely
                eliminate our use of global variables, thereby mitigating one of JavaScript’s worst features
            </p>
        </div>
        <div id="layer4" class="step" data-x="4000" data-y="0" data-scale="1">
            <h1>Structuration and Quality</h1>
        </div>
        <div id="layer5" class="step" data-x="5000" data-y="0" data-scale="1">
            <h1>Typescript</h1>
        </div>
    </div>
    <script src="/lib/impress.js"></script>
    <script>
        var rootElement = document.getElementById("impress");
        rootElement.addEventListener("impress:init", function () {
            console.log("Impress init");
        });
        impress().init();
    </script>
</body>

</html>